- [JVM](#jvm)
  - [1. 介绍下Java内存区域](#1-介绍下java内存区域)
  - [2. Java创建对象的过程](#2-java创建对象的过程)
  - [3. Java对象的内存布局](#3-java对象的内存布局)
  - [4. JVM如何判断对象是否需要回收](#4-jvm如何判断对象是否需要回收)
  - [5. 有哪些常见的GC算法？](#5-有哪些常见的gc算法)
  - [6. Minor GC和Full GC的触发条件](#6-minor-gc和full-gc的触发条件)
  - [7. 常用的垃圾收集器的特点](#7-常用的垃圾收集器的特点)
  - [8. 类加载器的种类](#8-类加载器的种类)
  - [9. 双亲委派模型](#9-双亲委派模型)
  - [10. JDBC与双亲委派模型](#10-jdbc与双亲委派模型)
  - [11. 说说Java的GC机制](#11-说说java的gc机制)
  - [12. JVM类加载的过程](#12-jvm类加载的过程)
  - [13. Java的四种引用类型](#13-java的四种引用类型)
  - [14. Class.forName()和ClassLoader.loadClass()的区别](#14-classforname和classloaderloadclass的区别)
  - [15. 栈的内存是如何回收的？](#15-栈的内存是如何回收的)
  - [16. 什么是守护线程？](#16-什么是守护线程)
  - [17. 什么是JVM的二次标记？](#17-什么是jvm的二次标记)
  - [18. 什么是CMS的浮动垃圾？](#18-什么是cms的浮动垃圾)
  - [19. 介绍一下Java的内存模型（JMM）](#19-介绍一下java的内存模型jmm)
  - [20. Java多态的实现原理](#20-java多态的实现原理)

# JVM

## 1. 介绍下Java内存区域
Java的内存区域分为堆、方法区（方法区中有一个运行时常量池）、程序计数器、JVM栈、本地方法栈。其中，堆和方法区是进程共有的，而栈和程序计数器是线程私有的。
+ **程序计数器**主要是用来记录代码运行的位置，解释器通过改变程序计数器来依次读取指令，同时，线程切换时也通过程序计数器来记录之前运行到的位置。
+ **JVM栈**则主要存储变量表、操作数、方法出口等信息。当调用Java方法时，栈帧会被插入到JVM栈中。
+ **本地方法栈**存储的信息与JVM栈相似，当调用Native方法时，栈帧会插入到本地方法栈。
+ **堆**则是用来存储对象和实例和数组的。对象的实例存储在堆中，而引用存储在栈中。
+ **方法区**主要存储已经加载过的类的信息、常量、静态变量等。

## 2. Java创建对象的过程
Java创建对象主要分为**类加载检查**、**分配内存**、**初始化**以及**将地址返回给引用**四个步骤。<br><br>

**类加载检查**指的是检查能否在方法区当中找到这个类的符号引用，并且这个符号引用代表的类是否进行过加载、连接、初始化的类加载过程（可见[12](#12-jvm类加载的过程)）

**分配内存**主要有指针碰撞和空闲列表两种方法：
+ **指针碰撞**指的是将内存划分为两块，使用过的放在一边，可分配的放在另一边，中间维护一个指针来标记两个区域的边界。一般用于JVM的内存规整的情况（即使用标记-复制算法或标记-整理算法时）这种方法最主要的问题就在于**线程不安全**。
+ **空闲列表**则是指JVM维护一个记录可用内存块的列表。一般用于JVM内存不规整的情况（即使用标记-清除算法时）。这种方法同样也会存在线程不安全的问题。

而为了保证**线程安全**，我们需要引入**CAS+失败重试**的机制以及**TLAB**的机制：
+ CAS+失败重试的机制可以保证内存分配操作的原子性。
+ **TLAB**是指给每个线程在Java堆的Eden区预先划分一块内存区域。可以在JVM参数中设置是否使用TLAB，如果使用，就会预先划分内存区域，当TLAB预先分配的内存用尽之后，再用CAS+失败重试的机制分配内存。

**初始化**则包括了三个部分：
+ 首先，将对象除了对象头的其他部分全部初始化为0
+ 之后，填写对象的对象头
+ 最后，执行\<init\>方法
+ 最后一步，则是将地址赋值给对象的引用。

但是，需要注意的是，这里初始化的第三步和第四步，也就是对象的初始化和地址赋值给引用，可能会被JVM进行**指令重排**。这也是为什么使用双重校验实现单例模式时需要给对象加volatile修饰。

## 3. Java对象的内存布局
与[Java并发-13](Java并发.md#13-对象头中包含哪些内容)相同。
Java的对象的内存布局主要包括对象头、实例数据和对齐填充。
**对象头**主要分为Mark Word和Klass Point两个部分：
+ Mark Word主要存储了类的基本信息，如hashcode、分代年龄、轻量级锁指针、重量级锁指针、偏向锁持有线程、偏向锁时间戳、GC标记等等。
+ Klass Point存储了指向类元数据的指针，用来标识对象是哪个类的对象。

## 4. JVM如何判断对象是否需要回收
主要有两种算法来判断对象是否需要回收：
+ **RC算法**。为每个对象添加一个计数器，记录指向这个对象的引用个数。这种方法实现相对比较简单，但问题在于无法解决循环引用的问题。
+ **可达性分析算法**。从GC Roots出发，利用引用关系向下搜索，如果某个对象对于GC Root不可达，就说明这个对象不可能再被使用。

GC Root主要有：
+ JVM栈中引用的对象
+ 本地方法引用的对象
+ 方法区中常量引用的对象，如字符串常量
+ 方法区中类静态属性引用的对象
+ 被同步锁锁定的对象

## 5. 有哪些常见的GC算法？
常见的GC算法主要有标记-清除、标记-复制和标记-整理三种：
+ **标记-清除算法**是在进行可达性分析之后，标记出所有需要回收的对象，并将其清除。标记-清除算法可能产生**内存碎片**，并且GC效率不稳定。
+ **标记-复制算法**将Java堆的**新生代**划分为一块Eden区和两块Survivor区。87每次分配内存只使用Eden区和其中的一块Survivor区，发生GC时，将仍然存活的对象复制到另一块Survivor区。而如果剩余的Survivor空间不足以存放剩下的对象，剩余的对象就会通过**分配担保机制**进入老年代。标记-复制算法当中，如果Survivor区较大，就会造成比较严重的内存空间浪费；而如果Survivor区较小，就必须有额外的空间进行分配担保。
+ **标记-整理算法**和标记-清除算法相似，但是清除的过程不是直接清除内存，而是将仍然存活的对象移动到内存的一侧。一般用于**老年代**的GC，移动对象的过程会触发STW。

## 6. Minor GC和Full GC的触发条件
**Minor GC**（Young GC）是目标仅有新生代的GC，一般在**Eden区满**的情况下发生。
**Full GC**是收集整个Java堆和方法区的GC，发生的情况如下：
+ 老年代或方法区空间不足
+ 进入老年代的对象大于老年代可用内存
+ Minor GC后放入的Survivor区（To space）内存不足
+ 调用System.gc()

## 7. 常用的垃圾收集器的特点
+ **Serial/Serial Old**使用**单线程**进行GC，同时会暂停所有其他工作线程（STW），等到所有工作线程到达安全点之后，对于**新生代**使用**标记-复制算法**，对于**老年代**使用**标记-整理算法**。Serial/Serial Old的内存消耗最小，同时没有切换线程的开销。
+ **ParNew**则是“多线程并行版”的Serial
+ **Parallel/Parallel Old**支持**多线程**并行，其中**Parallel Scavenge**基于**标记-复制**算法，而**Parallel Old**基于**标记-整理**算法。它是以**吞吐量**为目标，而不是以响应时间为目标。目前JDK8就是使用Parallel Scavenge + Parallel Old。
+ **CMS**则是以最短停顿时间为目标的垃圾收集器。它是以**标记-清除**算法为基础实现的，大致过程如下：
  1. **初始标记**：暂停其他所有线程，并记录与GC Root直接相连的对象，这个过程会发生STW。
  2. **并发标记**：同时开启GC线程和用户线程，记录可达对象。
  3. **重新标记**：为了修复并发标记阶段用户线程运行带来的可达性变化，这个过程也会发生STW。
  4. **并发清除**：开启用户线程，同时GC线程并发回收未被标记的对象。
在上述阶段当中，只有初始标记和重新标记阶段会发生**STW**。
+ **G1**是面向服务器、响应时间优先的一款垃圾收集器，它可以充分利用多核环境来缩短STW的时间。与传统的GC收集器不同，G1收集器的不同代内存空间分布并不是连续的，而是被分为若干个Region。同时，G1还实现了一个**停顿预测模型**，使得用户可以指定期望的停顿时间。<br><br>
G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。G1的Young GC就是根据用户允许的收集时间，选择若干数量的年轻代Region进行GC；Mixed GC则选中所有年轻代的Region，以及一部分的老年代Region（根据收益选择）。<br><br>
需要注意的是，G1不支持Full GC，如果需要Full GC会调用Serial Old收集器进行。<br><br>
G1收集器的GC过程和CMS相似，分为初始标记、并发标记、最终标记和并发清除四个阶段。
+ **ZGC**采用标记-复制算法，并且标记、转移、重定位阶段都是**并发**的，因此停顿时间很短。

## 8. 类加载器的种类
类加载器的作用是将类从.class文件加载到内存，主要分为三种：
+ **BootstrapClassLoader**（启动类加载器）：由C++实现，负责加载JAVA_HOME/lib目录下的jar包和类
+ **ExtensionClassLoader**（扩展类加载器）：负责加载JRE_HOME/lib/ext目录下的jar包和类
+ **AppClassLoader**（应用程序类加载器）：面向用户的类加载器。

## 9. 双亲委派模型
系统中的ClassLoader在协同工作时会使用双亲委派模型。双亲委派模型是指，当类加载器需要加载类的时候，它会先把加载请求委派给父加载器，一直递归到顶层（即BootstrapClassLoader），当父类无法完成这个加载请求时，子类才会尝试进行加载。<br><br>
双亲委派模型可以避免类被不同的类加载器重复加载，从而产生两个同名但内容不同的类；同时可以避免Java的核心API遭到篡改。
而如果需要打破双亲委派模型，可以重写loadClass()方法。

## 10. JDBC与双亲委派模型
一般情况下，我们都应该遵守双亲委派模型。但是JDBC可能会破坏双亲委派模型。<br><br>
一般来说，我们如果用Class.forName()来加载驱动，这种情况下是不会破坏双亲委派模型的。而JDBC4.0之后，支持**SPI**服务模式，编程时可以不使用Class.forName()来加载驱动。实际上，是将Class.forName()的操作移动到了DriverManager类中执行。这里Class.forName()的调用者是DriverManager类，而DriverManager类在rt.jar当中，因此要使用BootstrapClassLoader，但是BootstrapClassLoader无法加载com.mysql.jdbc.Driver。此时，双亲委派模型的问题就出现了，即父类加载器无法调用子类加载器。因此，JDBC利用线程上下文类加载器打破了双亲委派模型，使得父类加载器去请求子类加载器完成类加载。

## 11. 说说Java的GC机制
首先，Java目前的GC机制都遵循“分代收集”的理论，即将Java堆划分成新生代和老年代两个区域。分代收集理论建立在弱分代假说和强分代假说两个假说的基础上：
+ **弱分代假说**：绝大多数对象的存活时间都很短
+ **强分代假说**：存活过越多次GC过程的对象就越难以消亡

同时，由于JVM对对象进行了分代，GC的范围也有所区分，常见的有Minor GC和Full GC。其中，Minor GC的目标只有新生代，而Full GC的目标包括整个Java堆和方法区。<br><br>

此外，对于JVM如何判断一个对象是否存活，主要有两种算法，一种是RC算法，一种是可达性分析算法。（可见[4](#4-jvm如何判断对象是否需要回收)）
+ RC算法维护一个计数器记录对象被引用数，但是这种方法无法处理循环引用的情况。
+ 可达性分析算法是从GC Roots出发判断对象是否可达，不可达则说明对象不存活。
对于GC算法，JVM主要使用的是标记-清除、标记-复制和标记-回收三种GC算法。（可见[5](#5-有哪些常见的gc算法))

## 12. JVM类加载的过程
类加载的过程主要包括：加载、连接、初始化三个步骤。
+ **加载**的主要工作是类的二进制字节流（如.class文件）读取到内存中，生成class对象。非数组类型对象的加载是由类加载器来实现的，类加载器在协同工作时会遵循双亲委派模型。
+ **连接**过程主要可以划分为验证、准备、解析三个阶段。**验证**过程主要验证文件格式、元数据、字节码和符号引用；**准备**阶段在方法区为类变量分配内存并给变量赋零值；**解析**阶段则是将常量池中的符号引用替换为直接引用的过程。
+ **初始化**执行<clinit>方法，根据使用者编写的Java代码来对类变量和其他资源进行初始化。

## 13. Java的四种引用类型
Java的四种引用类型分别是强引用、软引用、弱引用和虚引用：
+ **强引用**：如果一个对象具有强引用，那么这个对象就一定不会被GC，JVM宁可抛出OOM也不会回收具有强引用的对象。
+ **软引用**：如果一个对象具有软引用，那么内存空间足够的时候不会被GC，只有内存空间不足时才会被回收。
+ **弱引用**：在GC线程扫描时，如果发现一个对象只具有弱引用，那么无论内存空间是否足够，都会回收这个对象。弱引用可以和引用队列一起使用，如果弱引用的对象将被回收，这个弱引用会被加入到引用队列当中。
+ **虚引用**：如果一个对象只具有虚引用，那么就相当于它不具有任何引用，因此随时可能会被回收。虚引用必须和引用队列一起使用，当虚引用的对象被回收之前，虚引用会被加入到引用队列当中。

其中，强引用在代码中普遍存在，软引用和弱引用可以用作缓存，而虚引用一般用于监控对象是否被GC。

## 14. Class.forName()和ClassLoader.loadClass()的区别
首先需要提到JVM加载类的过程，主要是加载、连接（分为验证、准备、解析）和初始化，具体可见[12](#12-jvm类加载的过程)。
ClassLoader.loadClass()方法**只进行加载**，即将.class文件读取到内存当中，而没有进行后续的连接和初始化工作。
**Class.forName()**则会在进行**加载**之后，进行**连接**和**初始化**的操作。另外，Class.forName()会使用调用该方法的类的类加载器来加载类。

## 15. 栈的内存是如何回收的？
在方法执行结束之后，对应方法的栈帧就会被回收，而不像堆中的内存那样需要通过GC来实现回收。

## 16. 什么是守护线程？
守护线程是指为其他线程服务的线程（如GC线程）。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。需要注意，守护线程不能持有需要关闭的资源。

## 17. 什么是JVM的二次标记？
JVM在进行GC的过程中实际上会进行两次标记，第一次是通过可达性分析发现对象到GC Roots之间没有任何引用链相连。这时会出现两种情况，如果对象没有重写finalize()方法，那么该对象就会被直接认为是可回收的；而如果对象重写了finalize()方法，并且该方法还没有被执行过，这个方法就会被放入F-Queue当中，F-Queue中的对象将会进行第二次标记。<br><br>

如果F-Queue中的对象在经过finalize()的调用后，重新获得了GC Roots的引用链联系，那么这个对象就不会被回收；否则，就会被标记为可以回收。

## 18. 什么是CMS的浮动垃圾？
CMS在进行**并发标记**的过程中，用户线程仍在执行，这个过程中就可能会产生新的垃圾，而这些垃圾并不会在重新标记阶段被标记出来（重新标记阶段只负责处理那些之前被标记为垃圾，但在并发标记阶段又获得了引用的对象），需要等到下一次GC才能得到回收，这种对象就被成为浮动垃圾。<br><br>

根据Oracle官方文档，G1收集器也会存在浮动垃圾的问题。

## 19. 介绍一下Java的内存模型（JMM）
Java当中，所有实例对象、静态域以及数组元素存储在堆中，而局部变量和方法参数则存储在线程私有的栈中。我们这里讨论内存模型，主要讨论的就是前者，存储在堆中的变量。<br><br>

Java将所有线程共享的变量存储在主存（Main Memory）当中，此外，每个线程还有其工作内存（也称为本地内存），工作内存中存储了变量的副本，线程对变量的操作都经由工作内存完成。（关于工作内存导致的可见性问题，可联系[Java并发-4](Java并发.md#4-volatile修饰符的作用)中的volatile相关知识）

## 20. Java多态的实现原理
多态的底层原理是动态绑定，即在运行时才将方法调用和方法实现绑定起来。<br><br>
这里需要提及，JVM的方法调用指令有五个：
+ invokestatic: 调用静态方法
+ invokespecial: 调用实例构造器<init>方法、私有方法和父类方法（即super关键字调用的方法）
+ invokevirtual: 调用虚方法（这里的虚方法指除了invokestatic和invokespecial的方法，以及final方法）
+ invokeinterface: 调用接口方法（会在运行时确定一个实现方法的对象）
+ invokedynamic: 动态指定调用的方法

其中，动态绑定主要使用invokevirtual和invokeinterface，恰好对应多态的两种常见形式，重写父类方法以及实现接口。<br><br>

Invokevirtual指令在执行时，会先从被调用的对象（receiver）的类中查找对应的方法，如果没找到才会去父类当中查找，而不是按照引用的类型来查找方法。<br><br>

上述分派方式的实现形式是**方法表**，JVM中每个类的内存空间中有一块方法表，当中存储着实例方法的直接引用（不包含私有方法）。按照Object类的实例方法→父类的实例方法→子类的实例方法的顺序存储，当子类重写了父类的方法时，该方法第一个出现位置存储的直接引用会被转向子类的方法实现（即位置仍在父类方法位置）。

